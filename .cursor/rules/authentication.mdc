# Authentication System

Complete guide to the authentication system for staff users and API integrations.

## Table of Contents

1. [Overview](#overview)
2. [Staff Authentication (JWT)](#staff-authentication-jwt)
3. [API Key Authentication](#api-key-authentication)
4. [Token Configuration](#token-configuration)
5. [Middleware & Authorization](#middleware--authorization)
6. [Permissions System](#permissions-system)
7. [Event Tracking](#event-tracking-with-authentication)
8. [Security Best Practices](#security-best-practices)
9. [Database Schema](#database-schema)
10. [Route Protection](#route-protection)
11. [Frontend Integration](#frontend-integration)
12. [Testing](#testing)
13. [Troubleshooting](#troubleshooting)

---

## Overview

The authentication system provides secure access control for two types of users:

1. **Staff Users** - Dashboard users (admin, customer_care, manager, etc.) authenticated via JWT tokens
2. **API Users** - External integrations authenticated via API keys

Both authentication methods are built on top of Supabase for staff and custom implementation for API keys.

### üöÄ Key Features

- **JWT-based authentication** for staff users via Supabase Auth
- **API key authentication** for external integrations
- **Permanent tokens by default** - Both JWT (configurable) and API keys
- **Role-based access control** (admin, manager, customer_care, etc.)
- **Permission-based authorization** (granular JSONB permissions)
- **Automatic user sync** between Supabase Auth and users table
- **IP whitelisting** for API keys (optional)
- **Rate limiting** support for API keys
- **Secure password handling** via Supabase (never stored in your database)

---

## Staff Authentication (JWT)

### Authentication Flow

1. User logs in with email/password
2. Server validates credentials with Supabase
3. Returns JWT access token and refresh token
4. Client includes token in Authorization header for subsequent requests
5. Middleware validates token and attaches user to request

### Creating a Staff User

Staff users are created in Supabase Auth and automatically synced to your database.

**Via Supabase Dashboard:**

1. Go to Supabase Dashboard ‚Üí **Authentication** ‚Üí **Users**
2. Click **Add User**
3. Fill in user details:
   ```
   Email: admin@yourcompany.com
   Password: (secure password)
   ```
4. Add **User Metadata** (important!):
   ```json
   {
     "full_name": "John Admin",
     "first_name": "John",
     "last_name": "Admin",
     "role": "admin"
   }
   ```
5. Click **Create User**

The user will automatically sync to the `users` table via database triggers.

**Available Roles:**
- `admin` - Full system access
- `manager` - Management access
- `customer_care` - Customer support access
- `inventory_manager` - Inventory management
- `viewer` - Read-only access

### Login (Get JWT Token)

```bash
curl --location --request POST 'http://localhost:3010/api/auth/login' \
--header 'Content-Type: application/json' \
--data-raw '{
  "email": "admin@yourcompany.com",
  "password": "securepassword123"
}'
```

**Response:**
```json
{
  "success": true,
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "v1_MQ3PJf...",
  "expires_in": 315360000,
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "email": "admin@yourcompany.com",
    "full_name": "John Admin",
    "first_name": "John",
    "last_name": "Admin",
    "role": "admin",
    "email_verified": true
  }
}
```

**Token Details:**
- `access_token` - Use for API requests
- `refresh_token` - Use to get new access token (if token expiration is configured)
- `expires_in` - Seconds until access token expires (configurable in Supabase, can be set to 10 years)

### Using JWT Token

Include the access token in the Authorization header for all protected requests:

```bash
curl --location --request POST 'http://localhost:3010/api/server/order/query' \
--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...' \
--header 'Content-Type: application/json' \
--data-raw '{
  "page": 1,
  "limit": 50
}'
```

### Refresh Token (Optional)

If your access token expires, use the refresh token to get a new one:

```bash
curl --location --request POST 'http://localhost:3010/api/auth/refresh' \
--header 'Content-Type: application/json' \
--data-raw '{
  "refresh_token": "v1_MQ3PJf..."
}'
```

### Get Current User

Retrieve information about the currently authenticated user:

```bash
curl --location --request GET 'http://localhost:3010/api/auth/me' \
--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'
```

**Response:**
```json
{
  "success": true,
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "auth_user_id": "auth-uuid-from-supabase",
    "email": "admin@yourcompany.com",
    "full_name": "John Admin",
    "role": "admin",
    "permissions": {
      "orders": {
        "read": true,
        "write": true,
        "delete": true
      },
      "products": {
        "read": true,
        "write": true
      }
    },
    "active": true,
    "email_verified": true,
    "last_login_at": "2026-01-16T10:30:00.000Z"
  }
}
```

---

## API Key Authentication

### Overview

API keys provide permanent authentication for external integrations, mobile apps, webhooks, and third-party services.

**Key Features:**
- ‚úÖ **Permanent by default** - No expiration unless explicitly set
- ‚úÖ **Role-based access** - Assign roles like regular users
- ‚úÖ **Granular permissions** - JSONB permissions for fine control
- ‚úÖ **IP whitelisting** - Optional IP restrictions
- ‚úÖ **One-time view** - Full key shown only on creation
- ‚úÖ **Prefix identification** - Easy key identification without exposing full key

### Creating an API Key

API keys are created via the API (requires admin authentication):

```bash
curl --location --request POST 'http://localhost:3010/api/server/api-users/create' \
--header 'Authorization: Bearer <admin-jwt-token>' \
--header 'Content-Type: application/json' \
--data-raw '{
  "name": "Mobile App Integration",
  "description": "API key for iOS/Android mobile apps",
  "role": "mobile_app",
  "permissions": {
    "orders": {
      "read": true,
      "write": true,
      "delete": false
    },
    "products": {
      "read": true,
      "write": false
    },
    "customers": {
      "read": true,
      "write": true,
      "delete": false
    }
  },
  "allowed_ips": null,
  "rate_limit": 5000
}'
```

**Response:**
```json
{
  "success": true,
  "api_user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "Mobile App Integration",
    "description": "API key for iOS/Android mobile apps",
    "api_key": "sk_mobile_app_a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6",
    "api_key_prefix": "sk_mobile_app_a1b2c...",
    "role": "mobile_app",
    "permissions": {
      "orders": {
        "read": true,
        "write": true,
        "delete": false
      },
      "products": {
        "read": true,
        "write": false
      },
      "customers": {
        "read": true,
        "write": true,
        "delete": false
      }
    },
    "allowed_ips": null,
    "rate_limit": 5000,
    "expires_at": null,
    "active": true,
    "created_at": "2026-01-16T10:30:00.000Z",
    "_warning": "Save this API key securely. It will not be shown again."
  }
}
```

**‚ö†Ô∏è IMPORTANT:** The full `api_key` is **only shown once**. Save it immediately!

### API Key Fields

#### Required Fields

**`name`** (string)
- Human-readable name for the API key
- Example: "Warehouse Integration", "Mobile App v2"

**`role`** (string)
- Available roles:
  - `integration` - General integrations (default)
  - `external_api` - Third-party API access
  - `webhook` - Webhook endpoints
  - `mobile_app` - Mobile applications

#### Optional Fields

**`description`** (string)
- Detailed description of the API key's purpose

**`permissions`** (object or null)
- Granular JSONB permissions (nested object with boolean values)
- Set to `null` for **superuser access** (all permissions allowed)
- Example with specific permissions:
  ```json
  {
    "orders": {
      "read": true,
      "write": true,
      "delete": false
    },
    "products": {
      "read": true,
      "write": false
    }
  }
  ```
- Example for superuser (all permissions):
  ```json
  {
    "name": "Admin Integration",
    "role": "integration",
    "permissions": null
  }
  ```

**`allowed_ips`** (array of strings)
- IP whitelist for security
- Set to `null` or `[]` to allow all IPs
- Example: `["192.168.1.100", "10.0.0.50"]`

**`rate_limit`** (integer)
- Requests per hour (default: 1000)
- Example: `5000` for high-traffic apps

**`expires_at`** (timestamp)
- Expiration date (default: `null` - permanent)
- Example: `"2027-12-31T23:59:59.000Z"` (only if you need temporary keys)

### Using API Key

Include the API key in the `X-API-Key` header:

```bash
curl --location --request POST 'http://localhost:3010/api/server/order/query' \
--header 'X-API-Key: sk_mobile_app_a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6' \
--header 'Content-Type: application/json' \
--data-raw '{
  "page": 1,
  "limit": 50
}'
```

### JavaScript Example

```javascript
const apiKey = 'sk_mobile_app_a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6';

const response = await fetch('http://localhost:3010/api/server/order/query', {
  method: 'POST',
  headers: {
    'X-API-Key': apiKey,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    page: 1,
    limit: 50
  })
});

const data = await response.json();
```

### Managing API Keys

#### Query API Keys

```bash
curl --location --request POST 'http://localhost:3010/api/server/api-users/query' \
--header 'Authorization: Bearer <admin-jwt-token>' \
--header 'Content-Type: application/json' \
--data-raw '{
  "page": 1,
  "limit": 50,
  "active": true
}'
```

**Note:** Full `api_key` is never returned in query/retrieve responses, only the prefix.

#### Modify API Key

Update name, description, permissions, or rate limit:

```bash
curl --location --request PUT 'http://localhost:3010/api/server/api-users/modify/<api-user-id>' \
--header 'Authorization: Bearer <admin-jwt-token>' \
--header 'Content-Type: application/json' \
--data-raw '{
  "name": "Mobile App Integration - Updated",
  "rate_limit": 10000,
  "permissions": {
    "orders": {
      "read": true,
      "write": true
    },
    "products": {
      "read": true,
      "write": true
    }
  }
}'
```

#### Deactivate API Key

Temporarily disable without deleting:

```bash
curl --location --request PUT 'http://localhost:3010/api/server/api-users/modify/<api-user-id>' \
--header 'Authorization: Bearer <admin-jwt-token>' \
--header 'Content-Type: application/json' \
--data-raw '{
  "active": false
}'
```

#### Delete API Key

```bash
curl --location --request DELETE 'http://localhost:3010/api/server/api-users/delete/<api-user-id>' \
--header 'Authorization: Bearer <admin-jwt-token>'
```

---

## Token Configuration

### Configuring Permanent/Long-Lived Tokens

#### For Staff Users (JWT Tokens)

JWT tokens are managed by Supabase. To make them effectively permanent:

**Step 1: Configure in Supabase Dashboard**

1. Go to your Supabase project dashboard
2. Navigate to **Authentication** ‚Üí **Settings**
3. Scroll to **Auth** section
4. Find **JWT Expiry** settings
5. Set to maximum value:
   - **JWT expiry limit**: `315360000` (10 years in seconds)
   - Or use the maximum value allowed by your Supabase plan

**Step 2: Optional - Disable Refresh Token Rotation**

```
Refresh Token Rotation Enabled: No
Refresh Token Reuse Interval: 315360000
```

This prevents automatic token rotation.

**Step 3: Verify Configuration**

After configuring, test the login endpoint:

```bash
curl -X POST http://localhost:3010/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "admin@company.com",
    "password": "password"
  }'
```

Check that `expires_in` shows your configured value (e.g., `315360000` instead of `3600`).

#### For API Users (API Keys)

API keys are **already permanent by default** - no configuration needed!

```json
{
  "name": "Mobile App",
  "role": "mobile_app"
  // No expires_at = permanent
}
```

### Supabase Configuration Limits

**Hosted Supabase (supabase.com):**
- **Free Tier:** May have limits on max JWT expiry (typically 7 days)
- **Pro Tier:** Higher limits, can set up to 10 years or more
- **Enterprise:** Full control over JWT expiry

**Self-Hosted Supabase:**
- Full control via environment variables
- Configure in `supabase/config.toml` or docker-compose:
  ```yaml
  GOTRUE_JWT_EXP: "315360000"  # 10 years
  ```

### Summary

| Authentication Type | Expiration | Configuration |
|-------------------|-----------|---------------|
| **Staff JWT** | Configurable in Supabase | Set to max value (10 years) |
| **API Keys** | Permanent by default | Already configured |

---

## Middleware & Authorization

### Staff Authentication Middleware

**`authenticateUser`** - Validates JWT and attaches user to `req.user`

```javascript
const { authenticateUser } = require('../middleware/auth');

router.post('/query', authenticateUser, async (req, res) => {
  // req.user is available here
  const userId = req.user.id;
  const userRole = req.user.role;
});
```

**`requireRole(roles)`** - Restricts access by role

```javascript
const { authenticateUser, requireRole } = require('../middleware/auth');

// Only admin and manager can access
router.delete('/delete/:id', 
  authenticateUser, 
  requireRole(['admin', 'manager']), 
  async (req, res) => {
    // Only admins and managers reach here
  }
);
```

**`optionalAuth`** - Authenticates if token present, continues otherwise

```javascript
const { optionalAuth } = require('../middleware/auth');

// Works with or without authentication
router.get('/public-data', optionalAuth, async (req, res) => {
  if (req.user) {
    // Authenticated - show personalized data
  } else {
    // Not authenticated - show public data
  }
});
```

### API Key Authentication Middleware

**`authenticateApiUser`** - Validates API key and attaches to `req.apiUser`

```javascript
const { authenticateApiUser } = require('../middleware/api-auth');

router.post('/query', authenticateApiUser, async (req, res) => {
  // req.apiUser is available here
  const apiUserId = req.apiUser.id;
  const apiUserName = req.apiUser.name;
});
```

**`requireApiRole(roles)`** - Restricts access by API user role

```javascript
const { authenticateApiUser, requireApiRole } = require('../middleware/api-auth');

router.delete('/delete/:id', 
  authenticateApiUser, 
  requireApiRole(['admin_api', 'manager_api']), 
  async (req, res) => {
    // Only specific API roles reach here
  }
);
```

**`requireApiPermission(permission)`** - Checks granular permissions using dot notation

```javascript
const { authenticateApiUser, requireApiPermission } = require('../middleware/api-auth');

router.post('/create', 
  authenticateApiUser, 
  requireApiPermission('orders.write'), 
  async (req, res) => {
    // Only API users with orders.write permission reach here
  }
);

// More examples:
// requireApiPermission('products.read')
// requireApiPermission('customers.delete')
// requireApiPermission('inventory.write')
```

---

## Event Tracking with Authentication

The authentication system integrates with the event system to track who performed each action.

### Automatic Actor Tracking

When using `getEventContext(req)`, actor info is automatically extracted:

```javascript
const { captureEvent } = require('../utils/events');
const { getEventContext } = require('../utils/event-context');

// In a route handler
router.post('/create', authenticateUser, async (req, res) => {
  const order = await createOrder(orderData);
  
  // Automatically captures staff user info
  const eventContext = getEventContext(req);
  
  await captureEvent({
    name: 'order.create',
    entity_type: 'order',
    entity_id: order.id,
    payload: { ... },
    ...eventContext
  });
});
```

### Actor Types in Events

**Staff User:**
```javascript
{
  actorInfo: {
    type: 'staff',
    id: 'user-uuid',
    name: 'John Admin',
    email: 'admin@company.com',
    role: 'admin'
  },
  source: 'dashboard'
}
```

**API User:**
```javascript
{
  actorInfo: {
    type: 'api_user',
    id: 'api-user-uuid',
    name: 'Mobile App Integration'
  },
  source: 'api'
}
```

**Customer (Storefront):**
```javascript
{
  actorInfo: {
    type: 'customer',
    id: null, // Not stored for privacy
    name: 'Jane Customer',
    email: 'customer@example.com'
  },
  source: 'storefront'
}
```

**System:**
```javascript
{
  actorInfo: {
    type: 'system',
    id: null,
    name: 'Automated Process'
  },
  source: 'system'
}
```

---

## Permissions System

### Overview

The system supports two types of permission checks:

1. **Role-Based Access Control (RBAC)** - Simple role checking (admin, manager, etc.)
2. **Granular Permissions** - Fine-grained permission checking for API users

### For Staff Users

Staff users use **role-based access** only. Check roles using middleware:

```javascript
const { authenticateUser, requireRole } = require('../middleware/auth');

// Only admin can delete
router.delete('/delete/:id', 
  authenticateUser, 
  requireRole(['admin']), 
  async (req, res) => {
    // Only admin role reaches here
  }
);

// Admin or manager can modify
router.put('/modify/:id', 
  authenticateUser, 
  requireRole(['admin', 'manager']), 
  async (req, res) => {
    // Admin or manager reaches here
  }
);
```

**Staff user permissions JSONB field** is stored in the database but **not currently enforced by middleware**. You can manually check it in your code:

```javascript
router.delete('/order/delete/:id', authenticateUser, async (req, res) => {
  // Manual permission check
  if (req.user.role !== 'admin' && !req.user.permissions?.orders?.delete) {
    return res.status(403).json({
      success: false,
      error: 'Permission denied: orders.delete required'
    });
  }
  
  // Proceed with deletion
});
```

### For API Users

API users support **both role and granular permission checking**:

#### Role-Based Checking

```javascript
const { authenticateApiUser, requireApiRole } = require('../middleware/api-auth');

router.post('/webhook', 
  authenticateApiUser, 
  requireApiRole(['webhook', 'integration']), 
  async (req, res) => {
    // Only webhook or integration API keys can access
  }
);
```

#### Granular Permission Checking

```javascript
const { authenticateApiUser, requireApiPermission } = require('../middleware/api-auth');

// Check specific permission using dot notation
router.post('/orders/create', 
  authenticateApiUser, 
  requireApiPermission('orders.write'), 
  async (req, res) => {
    // Only API keys with orders.write: true can access
  }
);

router.delete('/products/:id', 
  authenticateApiUser, 
  requireApiPermission('products.delete'), 
  async (req, res) => {
    // Only API keys with products.delete: true can access
  }
);
```

### Permission Structure

Permissions are stored as JSONB with nested objects and boolean values:

```json
{
  "orders": {
    "read": true,
    "write": true,
    "delete": false
  },
  "products": {
    "read": true,
    "write": true,
    "delete": false
  },
  "customers": {
    "read": true,
    "write": false,
    "delete": false
  },
  "inventory": {
    "read": true,
    "write": true,
    "delete": false
  },
  "analytics": {
    "read": true,
    "export": false
  }
}
```

**Format:** Each resource has an object with action keys set to `true` (allowed) or `false` (denied).

### Common Actions

- `read` - Query, retrieve data
- `write` - Create, update data
- `delete` - Delete data
- `export` - Export reports
- `admin` - Full access to resource

**Note:** Permissions support nested dot notation (e.g., `orders.items.read`, `reports.analytics.export`)

### Superuser Access (Allow All Permissions)

To grant an API key **full access to all resources**, set `permissions` to `null`:

```bash
curl --location --request POST 'http://localhost:3010/api/server/api-users/create' \
--header 'Authorization: Bearer <admin-jwt-token>' \
--header 'Content-Type: application/json' \
--data-raw '{
  "name": "Internal Admin Tool",
  "role": "integration",
  "permissions": null
}'
```

**Response:**
```json
{
  "success": true,
  "api_user": {
    "id": "...",
    "name": "Internal Admin Tool",
    "permissions": null,
    "active": true
  }
}
```

**How it works:**
- API keys with `permissions: null` bypass all `requireApiPermission` checks
- They can access any endpoint that uses `requireApiPermission` middleware
- Useful for internal tools, admin integrations, or trusted systems
- ‚ö†Ô∏è **Use sparingly** - only for fully trusted integrations

**Example:**
```javascript
// This endpoint requires orders.write permission
router.post('/orders/create', 
  authenticateApiUser, 
  requireApiPermission('orders.write'), 
  async (req, res) => {
    // API keys with permissions: null can access (superuser)
    // API keys with permissions: {"orders": {"write": true}} can access
    // API keys with permissions: {"orders": {"write": false}} CANNOT access
  }
);
```

**When to use:**
- Internal admin tools
- Warehouse management systems (full access)
- Backend automation scripts
- Development/testing environments

**When NOT to use:**
- External partner integrations
- Mobile apps
- Third-party services
- Any untrusted systems

### Checking Permissions in Code

```javascript
const { requireApiPermission } = require('../middleware/api-auth');

// Basic permission check
router.post('/orders/create', 
  authenticateApiUser, 
  requireApiPermission('orders.write'), 
  async (req, res) => {
    // Only API users with orders.write: true reach here
    // OR API users with permissions: null (superuser)
  }
);

// Delete permission
router.delete('/orders/:id', 
  authenticateApiUser, 
  requireApiPermission('orders.delete'), 
  async (req, res) => {
    // Only API users with orders.delete: true reach here
    // OR API users with permissions: null (superuser)
  }
);

// Read-only permission
router.get('/products/:id', 
  authenticateApiUser, 
  requireApiPermission('products.read'), 
  async (req, res) => {
    // Only API users with products.read: true reach here
    // OR API users with permissions: null (superuser)
  }
);
```

**Note:** API keys with `permissions: null` bypass all permission checks (superuser access).

### Manual Permission Checking

You can also check permissions manually in your code:

```javascript
router.post('/orders/create', authenticateApiUser, async (req, res) => {
  // Check if superuser (null permissions)
  if (req.apiUser.permissions === null) {
    // Superuser - allow all
  } else {
    // Manual permission check
    if (!req.apiUser.permissions?.orders?.write) {
      return res.status(403).json({
        success: false,
        error: 'Permission denied: orders.write required'
      });
    }
  }
  
  // Proceed with order creation
});
```

### Best Practices

#### 1. Use Superuser Sparingly

Only use `permissions: null` for trusted, internal integrations:

```json
{
  "name": "Internal Admin Tool",
  "role": "integration",
  "permissions": null  // Superuser - use carefully!
}
```

For external integrations, always use specific permissions:

```json
{
  "name": "Partner Integration",
  "role": "external_api",
  "permissions": {
    "orders": {
      "read": true,
      "write": false
    }
  }
}
```

#### 2. Descriptive Permissions

Use clear, descriptive permission names:

```json
{
  "orders": {
    "read": true,
    "write": true,
    "refund": false,
    "cancel": true
  },
  "inventory": {
    "read": true,
    "write": true,
    "adjust": false
  }
}
```

#### 3. Principle of Least Privilege

Only grant necessary permissions:

```json
{
  "permissions": {
    "orders": {
      "read": true,
      "write": false,
      "delete": false
    },
    "inventory": {
      "read": true,
      "write": true,
      "delete": false
    }
  }
}
```

#### 4. Consistent Naming

Use consistent action names across resources:
- `read`, `write`, `delete` for basic CRUD
- `export`, `import` for data operations
- `approve`, `reject` for workflow actions

#### 5. Regular Audits

Periodically review API user permissions:

```sql
-- Find API users with delete permissions
SELECT name, permissions
FROM api_users
WHERE permissions @> '{"orders": {"delete": true}}'
AND active = true;

-- Find superuser API keys
SELECT name, role, created_at
FROM api_users
WHERE permissions IS NULL
AND active = true;
```

### Permission Levels Summary

| Permission Setting | Access Level | Use Case | Example |
|-------------------|--------------|----------|---------|
| `null` | **Superuser** - All permissions allowed | Internal admin tools, trusted systems | `{"permissions": null}` |
| Specific permissions | **Granular** - Only specified actions allowed | External integrations, mobile apps | `{"orders": {"read": true, "write": false}}` |
| Empty object `{}` | **No permissions** - All actions denied | Placeholder/inactive keys | `{"permissions": {}}` |

---

## Security Best Practices

### Password Security

- ‚úÖ **Never store passwords** - Handled by Supabase Auth
- ‚úÖ **Use strong passwords** - Enforce complexity rules in Supabase
- ‚úÖ **Enable email verification** - Verify user emails before access

### Token Security

- ‚úÖ **Use HTTPS in production** - Never send tokens over HTTP
- ‚úÖ **Store tokens securely** - Use httpOnly cookies or secure storage
- ‚úÖ **Configure token lifetime** - Set in Supabase dashboard (can be very long)
- ‚úÖ **Validate on every request** - Middleware validates all tokens
- ‚úÖ **Revoke compromised tokens** - Delete user session in Supabase if needed

### API Key Security

- ‚ö†Ô∏è **Current implementation uses plain text** - For demo purposes only
- üî¥ **Production requirement:** Hash API keys before storing
- ‚úÖ **Use prefixes** - Easy identification (sk_live_, sk_test_)
- ‚úÖ **Use IP whitelisting** - Restrict to known IPs when possible
- ‚úÖ **Monitor usage** - Track API key activity via `last_used_at`
- ‚úÖ **Never commit to Git** - Use environment variables or secrets managers

### Role-Based Access

- ‚úÖ **Principle of least privilege** - Give minimum required permissions
- ‚úÖ **Use role hierarchy** - admin > manager > customer_care > viewer
- ‚úÖ **Granular permissions** - Use JSONB permissions for fine control
- ‚úÖ **Regular audits** - Review user roles and permissions

### IP Whitelisting for API Keys

Restrict API key usage to specific IP addresses:

```json
{
  "name": "Warehouse Integration",
  "allowed_ips": ["192.168.1.100", "203.0.113.50"]
}
```

**Behavior:**
- If `allowed_ips` is `null` or `[]` ‚Üí All IPs allowed
- If `allowed_ips` contains IPs ‚Üí Only those IPs allowed
- Requests from other IPs receive `403 Forbidden`

---

## Database Schema

### Users Table

Staff users synced from Supabase Auth.

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  auth_user_id UUID UNIQUE NOT NULL,
  email TEXT UNIQUE NOT NULL,
  full_name TEXT,
  first_name TEXT,
  last_name TEXT,
  phone TEXT,
  role TEXT NOT NULL DEFAULT 'viewer',
  permissions JSONB DEFAULT '{}'::jsonb,
  active BOOLEAN DEFAULT true,
  email_verified BOOLEAN DEFAULT false,
  avatar_url TEXT,
  locale TEXT DEFAULT 'en',
  timezone TEXT,
  last_login_at TIMESTAMPTZ,
  last_activity_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Automatic Sync Triggers:**
- `handle_auth_user_created` - Creates user when Supabase Auth user created
- `handle_auth_user_updated` - Updates user when Supabase Auth user updated
- `handle_auth_user_deleted` - Soft deletes user when Supabase Auth user deleted

### API Users Table

External integration users authenticated via API keys.

```sql
CREATE TABLE api_users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  api_key TEXT UNIQUE NOT NULL,
  api_key_prefix TEXT NOT NULL,
  role TEXT NOT NULL DEFAULT 'integration',
  permissions JSONB DEFAULT '{}'::jsonb,
  allowed_ips TEXT[],
  rate_limit INTEGER DEFAULT 1000,
  expires_at TIMESTAMPTZ,
  active BOOLEAN DEFAULT true,
  last_used_at TIMESTAMPTZ,
  created_by UUID,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

---

## Route Protection

### Public Routes (No Authentication)

```
/api/health
/api/auth/login
/api/auth/refresh
/api/storefront/checkout/create
/api/storefront/session/create
```

### Protected Routes (JWT Required)

```
/api/server/* (all dashboard endpoints)
/api/auth/me
```

All routes under `/api/server` require JWT authentication via `authenticateUser` middleware.

### Route Structure

```
/api
‚îú‚îÄ‚îÄ /auth (public login, protected me)
‚îú‚îÄ‚îÄ /storefront (public - customer facing)
‚îÇ   ‚îú‚îÄ‚îÄ /checkout
‚îÇ   ‚îî‚îÄ‚îÄ /session
‚îî‚îÄ‚îÄ /server (protected - admin dashboard)
    ‚îú‚îÄ‚îÄ /users
    ‚îú‚îÄ‚îÄ /order
    ‚îú‚îÄ‚îÄ /product
    ‚îú‚îÄ‚îÄ /customer
    ‚îú‚îÄ‚îÄ /checkout (admin view)
    ‚îî‚îÄ‚îÄ ... (all other modules)
```

---

## Frontend Integration

### React/TypeScript Example

**Auth Context:**

```typescript
import { createContext, useContext, useState, useEffect } from 'react';

interface User {
  id: string;
  email: string;
  full_name: string;
  role: string;
}

interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(
    localStorage.getItem('access_token')
  );

  const login = async (email: string, password: string) => {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });

    const data = await response.json();

    if (data.success) {
      localStorage.setItem('access_token', data.access_token);
      localStorage.setItem('refresh_token', data.refresh_token);
      setToken(data.access_token);
      setUser(data.user);
    }
  };

  const logout = () => {
    localStorage.removeItem('access_token');
    localStorage.removeItem('refresh_token');
    setToken(null);
    setUser(null);
  };

  // Fetch current user on mount
  useEffect(() => {
    if (token) {
      fetch('/api/auth/me', {
        headers: { 'Authorization': `Bearer ${token}` }
      })
        .then(res => res.json())
        .then(data => {
          if (data.success) {
            setUser(data.user);
          } else {
            logout();
          }
        });
    }
  }, [token]);

  return (
    <AuthContext.Provider value={{ user, login, logout, isAuthenticated: !!user }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within AuthProvider');
  return context;
};
```

**API Client with Auto-Refresh:**

```typescript
class ApiClient {
  private baseUrl = '/api';
  
  private async getToken(): Promise<string | null> {
    return localStorage.getItem('access_token');
  }

  private async refreshToken(): Promise<string | null> {
    const refreshToken = localStorage.getItem('refresh_token');
    if (!refreshToken) return null;

    const response = await fetch(`${this.baseUrl}/auth/refresh`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ refresh_token: refreshToken })
    });

    const data = await response.json();
    if (data.success) {
      localStorage.setItem('access_token', data.access_token);
      localStorage.setItem('refresh_token', data.refresh_token);
      return data.access_token;
    }

    return null;
  }

  async request(endpoint: string, options: RequestInit = {}) {
    let token = await this.getToken();

    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...(token && { 'Authorization': `Bearer ${token}` }),
        ...options.headers
      }
    });

    // If 401 and we have a refresh token, try to refresh
    if (response.status === 401 && localStorage.getItem('refresh_token')) {
      token = await this.refreshToken();
      
      if (token) {
        // Retry request with new token
        return fetch(`${this.baseUrl}${endpoint}`, {
          ...options,
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`,
            ...options.headers
          }
        });
      }
    }

    return response;
  }

  async get(endpoint: string) {
    const response = await this.request(endpoint);
    return response.json();
  }

  async post(endpoint: string, data: any) {
    const response = await this.request(endpoint, {
      method: 'POST',
      body: JSON.stringify(data)
    });
    return response.json();
  }
}

export const api = new ApiClient();
```

**Usage:**

```typescript
import { useAuth } from './contexts/AuthContext';
import { api } from './services/api';

function OrdersPage() {
  const { user, logout } = useAuth();
  const [orders, setOrders] = useState([]);

  useEffect(() => {
    api.post('/server/order/query', { page: 1, limit: 50 })
      .then(data => setOrders(data.data));
  }, []);

  return (
    <div>
      <h1>Welcome, {user?.full_name}</h1>
      <button onClick={logout}>Logout</button>
      {/* Orders list */}
    </div>
  );
}
```

---

## Testing

### Manual Testing with curl

**1. Login:**
```bash
TOKEN=$(curl -s -X POST http://localhost:3010/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@company.com","password":"password"}' \
  | jq -r '.access_token')
```

**2. Use Token:**
```bash
curl -X POST http://localhost:3010/api/server/users/query \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"page":1,"limit":50}'
```

**3. Test API Key:**
```bash
# Create API key (save the returned key)
curl -X POST http://localhost:3010/api/server/api-users/create \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name":"Test Key","role":"integration"}'

# Use API key
curl -X POST http://localhost:3010/api/server/order/query \
  -H "X-API-Key: sk_integration_..." \
  -H "Content-Type: application/json" \
  -d '{"page":1,"limit":10}'
```

### Postman Testing

**Step 1: Set Up Environment**

Create environment variables:
- `base_url`: `http://localhost:3010/api`
- `access_token`: (leave empty, will be auto-filled)

**Step 2: Login Request**

```
POST {{base_url}}/auth/login

Body:
{
  "email": "admin@company.com",
  "password": "password"
}

Tests Tab (auto-save token):
const response = pm.response.json();
if (response.success && response.access_token) {
    pm.environment.set("access_token", response.access_token);
}
```

**Step 3: Use Token**

```
POST {{base_url}}/server/users/query

Headers:
- Authorization: Bearer {{access_token}}

Body:
{
  "page": 1,
  "limit": 50
}
```

---

## Troubleshooting

### 401 Unauthorized

**Cause:** Token missing, invalid, or expired

**Solutions:**
- Verify token is included in Authorization header
- Check token format: `Bearer <token>`
- Try refreshing the token
- Re-login if refresh fails
- Check Supabase Auth status

### 403 Forbidden

**Cause:** User not found, inactive, or insufficient permissions

**Solutions:**
- Check user exists in users table
- Verify `active = true` for user
- Check user role has required permissions
- Verify API key has required permissions
- Check IP is in `allowed_ips` (for API keys)

### User Not Syncing from Supabase

**Cause:** Triggers not working or metadata missing

**Solutions:**
- Check triggers exist: `\df` in psql
- Verify user metadata in Supabase includes `role`
- Manually insert user in users table if needed
- Check Supabase logs for trigger errors

### API Key Not Working

**Cause:** Key invalid, expired, or IP restricted

**Solutions:**
- Verify API key is correct
- Check `expires_at` hasn't passed (if set)
- Verify your IP is in `allowed_ips` (if set)
- Check `active = true` for API user
- Verify key is included in `X-API-Key` header

### JWT Token Expires Too Quickly

**Cause:** Supabase JWT expiry not configured

**Solutions:**
- Go to Supabase Dashboard ‚Üí Authentication ‚Üí Settings
- Set JWT expiry limit to `315360000` (10 years)
- Wait 5-10 minutes for settings to propagate
- Test login again and check `expires_in` value

---

## Migration from Non-Authenticated System

If you're adding authentication to an existing system:

1. **Run migrations:**
   ```bash
   # 004_create_users_table.sql
   # 005_create_api_users_table.sql
   ```

2. **Create admin user in Supabase Auth**

3. **Configure long-lived tokens in Supabase** (optional)
   - Set JWT expiry to 315360000 seconds (10 years)

4. **Update frontend to use login endpoint**

5. **Add middleware to protected routes:**
   ```javascript
   const { authenticateUser } = require('../middleware/auth');
   router.use(authenticateUser); // Add to server routes
   ```

6. **Test all endpoints with authentication**

---

## Quick Reference

### Staff Authentication

| Action | Endpoint | Method | Auth Required |
|--------|----------|--------|---------------|
| Login | `/api/auth/login` | POST | No |
| Refresh Token | `/api/auth/refresh` | POST | No |
| Get Current User | `/api/auth/me` | GET | Yes (JWT) |

### API Key Management

| Action | Endpoint | Method | Auth Required |
|--------|----------|--------|---------------|
| Create API Key | `/api/server/api-users/create` | POST | Yes (JWT Admin) |
| Query API Keys | `/api/server/api-users/query` | POST | Yes (JWT Admin) |
| Retrieve API Key | `/api/server/api-users/retrieve/:id` | GET | Yes (JWT Admin) |
| Modify API Key | `/api/server/api-users/modify/:id` | PUT | Yes (JWT Admin) |
| Delete API Key | `/api/server/api-users/delete/:id` | DELETE | Yes (JWT Admin) |

### Using Authentication

**Staff (JWT):**
```bash
curl -H "Authorization: Bearer <token>" ...
```

**API Key:**
```bash
curl -H "X-API-Key: <api-key>" ...
```

---

## Support

For issues or questions:

1. Check this documentation
2. Review error logs in server console
3. Verify database migrations ran successfully
4. Check Supabase Auth status
5. Review middleware implementation

**Common Files:**
- `middleware/auth.js` - Staff authentication middleware
- `middleware/api-auth.js` - API key authentication middleware
- `utils/event-context.js` - Event actor tracking
- `routes/auth/` - Authentication endpoints
- `migrations/004_create_users_table.sql` - Users table setup
- `migrations/005_create_api_users_table.sql` - API users table setup

**Related Documentation:**
- **Users Module:** `/documentation/USERS/README.md`
- **Events System:** `/documentation/EVENTS/LIST_OF_EVENTS.md`
- **Database Schema:** `/documentation/Database.md`

